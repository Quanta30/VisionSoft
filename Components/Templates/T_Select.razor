@if(Layout == "1"){
    <div class="@ColSize">
        <div class="mb-3">
            <label >@Label</label>
            <select class="form-control" @bind="Value" @bind:after="OnValueChanged" 
                    @ref="reference" @onkeydown="HandleEnter">
                @foreach (var option in options)
                {
                    <option value="@option.Value" selected="@(option.Value == Value)">
                        @option.Text
                    </option>
                }
            </select>
        </div>
    </div>
}
else if(Layout == "2"){
    <select class="form-control form-control-sm" @bind="Value" @bind:after="OnValueChanged"
            @ref="reference" @onkeydown="HandleEnter">
        @foreach (var option in options)
        {
            <option value="@option.Value" selected="@(option.Value == Value)">
                @option.Text
            </option>
        }
    </select>
}

@code {
    [Parameter] public string Label {get; set;} = "";
    [Parameter] public string Value { get; set; } = "";
    [Parameter] public string Options { get; set; } = "";
    [Parameter] public string ColSize{get; set;} = "col-md-3";
    [Parameter] public string Layout {get; set;} = "1";
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public EventCallback OnChange{get; set;}
    
    // Add reference support
    [Parameter] public EventCallback<ElementReference> GetInputReference{get; set;}
    [Parameter] public ElementReference NextReference{get; set;}
    [Parameter] public bool FocusDefault{get; set;} = false;
    [Parameter] public EventCallback OnEnterPressed{get; set;}
    public ElementReference reference;
    
    private List<SelectOption> options = new List<SelectOption>();
    private string _lastOptions = "";
    
    protected override void OnInitialized()
    {
        // Only parse if Options parameter actually changed
        if (_lastOptions != Options)
        {
            Console.WriteLine("Options changed, re-parsing");
            _lastOptions = Options;
            ParseOptions();
        }
        else
        {
            Console.WriteLine("Options unchanged, skipping parse");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {   
       
        if(firstRender && GetInputReference.HasDelegate)
        {
            Console.WriteLine("T_Select: Sending reference to parent");
            await GetInputReference.InvokeAsync(reference);
        }
    }
    
    private void ParseOptions()
    {
        options.Clear();
        
        if (!string.IsNullOrEmpty(Options))
        {
            // Format: "CASH:Cash,CARD:Card,UPI:UPI"
            var pairs = Options.Split(',');
            foreach (var pair in pairs)
            {
                var parts = pair.Split(':');
                if (parts.Length == 2)
                {
                    options.Add(new SelectOption 
                    { 
                        Value = parts[0].Trim(), 
                        Text = parts[1].Trim() 
                    });
                }
            }
        }
    }
    
    private async Task OnValueChanged()
    {
        if(OnChange.HasDelegate) await OnChange.InvokeAsync();
        await ValueChanged.InvokeAsync(Value);
    }

    private async Task HandleEnter(KeyboardEventArgs e)
    {
        if(e.Key == "Enter" && !NextReference.Equals(default(ElementReference)))
        {
            Console.WriteLine("T_Select: Valid Input. Focusing on Next Input");
            await NextReference.FocusAsync();
        }
    }
    
    private class SelectOption
    {
        public string Value { get; set; }
        public string Text { get; set; }
    }
}