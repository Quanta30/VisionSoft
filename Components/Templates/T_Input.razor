@rendermode InteractiveServer





@if(Layout == 1){
    <div class="@ColSize">
        <div class="mb-3">
            <label >@Title</label>
            <input class="form-control @(ReadOnly ? "readonly-input" : "") @(isValid ? "":"is-invalid")"
                   placeholder="@Placeholder"
                   type="@Type"
                   value="@_internalValue"
                   @oninput="OnInputChanged"
                   readonly="@ReadOnly"
                   disabled="@ReadOnly"
                   step="@Step"
                   min="@Min"
                   max="@Max"
                   style="@(ReadOnly ? "background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;" : "")" 
                   maxlength="@(MaxLength > 0 && MaxLength < int.MaxValue ? MaxLength.ToString() : null)"
                   @ref="reference"
                   />
            

        @if  (_internalValue.Length == MaxLength)
        {
            <small class="text-danger mt-1 d-block">
                <i class="bi bi-exclamation-triangle"></i>
                Maximum length is @MaxLength characters. Current: @_internalValue.Length
            </small>
        }
        </div>
    </div>
}
else if(Layout == 2){
    <div class="row mb-2">
        <div class="col-6">
            <label class="form-label">@Title</label>
        </div>
        <div class="col-6">
            @if (DisplayContent != null)
            {
                @DisplayContent
            }
            else
            {
                <input type="@Type"
                       class="form-control form-control-sm @(ReadOnly ? "readonly-input" : "")"
                       value="@_internalValue"
                       @oninput="OnInputChanged"
                       placeholder="@Placeholder"
                       step="@Step"
                       min="@Min"
                       max="@Max" 
                       readonly="@ReadOnly"
                       disabled="@ReadOnly"
                       style="@(ReadOnly ? "background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;" : "")" 
                       maxlength="@(MaxLength > 0 && MaxLength < int.MaxValue ? MaxLength.ToString() : null)"
                       @ref="reference"
                       />
            }
        </div>
    </div>
}
else if(Layout == 3){
    // Inline layout for table cells
    <input type="@Type"
           class="form-control form-control-sm @(ReadOnly ? "readonly-input" : "")"
           value="@_internalValue"
           @oninput="OnInputChanged"
           placeholder="@Placeholder"
           step="@Step"
           min="@Min"
           max="@Max" 
           readonly="@ReadOnly"
           disabled="@ReadOnly"
           style="@(ReadOnly ? "background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;" : "")" 
           maxlength="@(MaxLength > 0 && MaxLength < int.MaxValue ? MaxLength.ToString() : null)"
           @ref="reference"
           />
}

<style>
    .readonly-input {
    using System.Reflection.Emit;
#line default
    color: #6c757d !important;
        cursor: not-allowed !important;
        border-color: #dee2e6 !important;
    }

    .readonly-input:focus {
        box-shadow: none !important;
        border-color: #dee2e6 !important;
    }

    .readonly-input::placeholder {
        color: #adb5bd !important;
    }


        /* Custom invalid styles with red shadow */
    .form-control.is-invalid {
        border-color: #dc3545 !important;
        box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25) !important;
    }

    .form-control.is-invalid:focus {
        border-color: #dc3545 !important;
        box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25) !important;
    }
</style>

@code {
    private string _internalValue = string.Empty;

    [Parameter] public string Value { get; set; } = string.Empty;//To Be Binded 
    [Parameter] public string Title { get; set; } = string.Empty;

    //Parameter for Input Box Properties and Styling
    [Parameter] public string Type { get; set; } = "text";
    [Parameter] public string Placeholder { get; set; } = "Enter value";
    [Parameter] public string Min { get; set; } = string.Empty;
    [Parameter] public string Max { get; set; } = string.Empty;
    [Parameter] public string Step { get; set; } = string.Empty;
    [Parameter] public string ColSize {get; set;} = "col-md-4";


    //Parameters For Validataion
    [Parameter] public int MaxLength {get; set;} = int.MaxValue;


    //Integer Variables
    [Parameter] public int Layout { get; set; } = 1; // Default layout

    //Boolean Variables
    [Parameter] public bool IsDisplayOnly { get; set; } = false;
    [Parameter] public bool ReadOnly { get; set; } = false;
    [Parameter] public bool isValid{get; set;} = true;
    [Parameter] public bool Required{get; set;} = false;
    [Parameter] public String FocusOn{get; set;}


    //EventCallbacks and RenderFragments
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public EventCallback<string> ChangeFunction{get; set;}
    [Parameter] public RenderFragment? DisplayContent { get; set; }
    
    private ElementReference reference;


    //Runs During (When Edit is clicked and variable is changed, it automatically updates the UI)
    //Component Creation, Parameters Updated, StateHasChanged Called in Parent Component
    protected override void OnParametersSet()
    {
        _internalValue = Value ?? string.Empty;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!string.IsNullOrEmpty(FocusOn) && FocusOn == Title)
        {
            await Focus();
        }
    }

    //Runs When Input is Changed In Input Area
    private async Task OnInputChanged(ChangeEventArgs e)
    {
        if (!ReadOnly)
        {
            string newValue = e.Value?.ToString() ?? string.Empty;
            
            // For date inputs, ensure ISO format
            if (Type == "date" && !string.IsNullOrEmpty(newValue))
            {
                if (DateTime.TryParse(newValue, out DateTime date))
                {
                    newValue = date.ToString("yyyy-MM-dd");
                }
            }
            
            _internalValue = newValue;
            await ValueChanged.InvokeAsync(_internalValue);
            if(ChangeFunction.HasDelegate){
                await ChangeFunction.InvokeAsync(_internalValue);
            }
        }
        Validate();
    }

    //Validate the Input
    public void Validate(){
        isValid = true;
        if(_internalValue.Length > MaxLength || (_internalValue == "" && Required)){
            isValid = false;
        }
    }

        public async Task Focus()
        {
            try
            {
                Console.WriteLine($"Focus requested for: {FocusOn}, Title: {Title}, Layout: {Layout}");
                
                if (!string.IsNullOrEmpty(FocusOn) && FocusOn == Title)
                {
                    // All layouts now have @ref="reference", so we can focus any of them
                    if (reference.Id != null)
                    {
                        Console.WriteLine($"Focusing Layout {Layout} element: {Title}");
                        await reference.FocusAsync();
                    }
                    else
                    {
                        Console.WriteLine($"Element reference not ready for {Title}");
                        // Try again after a small delay
                        await Task.Delay(50);
                        if (reference.Id != null)
                        {
                            await reference.FocusAsync();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error focusing element {Title}: {ex.Message}");
            }
        }


}